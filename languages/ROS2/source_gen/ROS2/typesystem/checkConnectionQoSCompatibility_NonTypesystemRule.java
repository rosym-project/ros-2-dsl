package ROS2.typesystem;

/*Generated by MPS */

import jetbrains.mps.lang.typesystem.runtime.AbstractNonTypesystemRule_Runtime;
import jetbrains.mps.lang.typesystem.runtime.NonTypesystemRule_Runtime;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.typesystem.inference.TypeCheckingContext;
import jetbrains.mps.lang.typesystem.runtime.IsApplicableStatus;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.AttributeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import org.jetbrains.mps.openapi.language.SEnumerationLiteral;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SEnumOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.errors.messageTargets.MessageTarget;
import jetbrains.mps.errors.messageTargets.NodeMessageTarget;
import jetbrains.mps.errors.IErrorReporter;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SProperty;

public class checkConnectionQoSCompatibility_NonTypesystemRule extends AbstractNonTypesystemRule_Runtime implements NonTypesystemRule_Runtime {
  public checkConnectionQoSCompatibility_NonTypesystemRule() {
  }
  public void applyRule(final SNode connection, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {
    ListSequence.fromList(SLinkOperations.getChildren(connection, LINKS.sources$zOdg)).visitAll(new IVisitor<SNode>() {
      public void visit(final SNode source) {
        ListSequence.fromList(SLinkOperations.getChildren(connection, LINKS.targets$zI6Q)).visitAll(new IVisitor<SNode>() {
          public void visit(SNode target) {

            //  Default QoS parameters 
            SNode system_default = AttributeOperations.getAttribute(SNodeOperations.cast(SNodeOperations.getParent(connection), CONCEPTS.System$7o), new IAttributeDescriptor.NodeAttribute(CONCEPTS.DefaultQoS$mx));

            SNode source_profile = SLinkOperations.getTarget(AttributeOperations.getAttribute(SLinkOperations.getTarget(SLinkOperations.getTarget(source, LINKS.ref$7ES7), LINKS.port$FRDg), new IAttributeDescriptor.NodeAttribute(CONCEPTS.CapabilityProfileAnnotation$9I)), LINKS.profile$BWnM);
            SNode target_profile = SLinkOperations.getTarget(AttributeOperations.getAttribute(SLinkOperations.getTarget(SLinkOperations.getTarget(target, LINKS.ref$7FnA), LINKS.port$FRDg), new IAttributeDescriptor.NodeAttribute(CONCEPTS.CapabilityProfileAnnotation$9I)), LINKS.profile$BWnM);

            String source_profile_name = ((source_profile != null) ? SPropertyOperations.getString(source_profile, PROPS.name$MnvL) : "default");
            String target_profile_name = ((target_profile != null) ? SPropertyOperations.getString(target_profile, PROPS.name$MnvL) : "default");

            // check for compatibility if the profiles are different 
            if (target_profile_name != source_profile_name) {
              // Reliability 
              SEnumerationLiteral source_reliability = ((Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(source_profile, LINKS.policies$ZwmD), CONCEPTS.DDS_Reliability$EL)).last() != null) ? SPropertyOperations.getEnum(Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(source_profile, LINKS.policies$ZwmD), CONCEPTS.DDS_Reliability$EL)).last(), PROPS.value$HFLS) : SPropertyOperations.getEnum(system_default, PROPS.reliability$KGFA));
              SEnumerationLiteral target_reliability = ((Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(target_profile, LINKS.policies$ZwmD), CONCEPTS.DDS_Reliability$EL)).last() != null) ? SPropertyOperations.getEnum(Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(target_profile, LINKS.policies$ZwmD), CONCEPTS.DDS_Reliability$EL)).last(), PROPS.value$HFLS) : SPropertyOperations.getEnum(system_default, PROPS.reliability$KGFA));
              // if source is BEST_EFFORT and target is RELIABLE then policies are incompatible 
              if (source_reliability.equals(SEnumOperations.getMember(MetaAdapterFactory.getEnumeration(0x331f7a18c6574dd7L, 0x870742124f20f67bL, 0x7358ab7c0bd70c5eL, "DDS.structure.ReliabilityEnumeration"), 0x7358ab7c0bd70c60L, "BEST_EFFORT")) && target_reliability.equals(SEnumOperations.getMember(MetaAdapterFactory.getEnumeration(0x331f7a18c6574dd7L, 0x870742124f20f67bL, 0x7358ab7c0bd70c5eL, "DDS.structure.ReliabilityEnumeration"), 0x7358ab7c0bd70c5fL, "RELIABLE"))) {
                {
                  final MessageTarget errorTarget = new NodeMessageTarget();
                  IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(connection, "The profiles " + source_profile_name + " and " + target_profile_name + " are incompatible due to reliability policy.", "r:32754cbf-4758-422a-8eaf-16202a1e987c(ROS2.typesystem)", "3788866084215889702", null, errorTarget);
                }
              }

              // Durability 
              SEnumerationLiteral source_durability = ((Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(source_profile, LINKS.policies$ZwmD), CONCEPTS.DDS_Durability$PO)).last() != null) ? SPropertyOperations.getEnum(Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(source_profile, LINKS.policies$ZwmD), CONCEPTS.DDS_Durability$PO)).last(), PROPS.value$XLjo) : SPropertyOperations.getEnum(system_default, PROPS.durability$KNg2));
              SEnumerationLiteral target_durability = ((Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(target_profile, LINKS.policies$ZwmD), CONCEPTS.DDS_Durability$PO)).last() != null) ? SPropertyOperations.getEnum(Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(target_profile, LINKS.policies$ZwmD), CONCEPTS.DDS_Durability$PO)).last(), PROPS.value$XLjo) : SPropertyOperations.getEnum(system_default, PROPS.durability$KNg2));
              // If source is VOLATILE and target is TRANSIENT_LOCAL then policies are incompatible 
              if (source_durability.equals(SEnumOperations.getMember(MetaAdapterFactory.getEnumeration(0x331f7a18c6574dd7L, 0x870742124f20f67bL, 0x7358ab7c0bd70c69L, "DDS.structure.DurabilityEnumeration"), 0x7358ab7c0bd70c6bL, "VOLATILE")) && target_durability.equals(SEnumOperations.getMember(MetaAdapterFactory.getEnumeration(0x331f7a18c6574dd7L, 0x870742124f20f67bL, 0x7358ab7c0bd70c69L, "DDS.structure.DurabilityEnumeration"), 0x7358ab7c0bd70c6aL, "TRANSIENT_LOCAL"))) {
                {
                  final MessageTarget errorTarget = new NodeMessageTarget();
                  IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(connection, "The profiles " + source_profile_name + " and " + target_profile_name + " are incompatible due to durability policy.", "r:32754cbf-4758-422a-8eaf-16202a1e987c(ROS2.typesystem)", "3788866084216224878", null, errorTarget);
                }
              }

              // Liveliness 
              SEnumerationLiteral source_liveliness = ((Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(source_profile, LINKS.policies$ZwmD), CONCEPTS.DDS_Liveliness$PN)).last() != null) ? SPropertyOperations.getEnum(Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(source_profile, LINKS.policies$ZwmD), CONCEPTS.DDS_Liveliness$PN)).last(), PROPS.value$EQed) : SPropertyOperations.getEnum(system_default, PROPS.liveliness$KMjY));
              SEnumerationLiteral target_liveliness = ((Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(target_profile, LINKS.policies$ZwmD), CONCEPTS.DDS_Liveliness$PN)).last() != null) ? SPropertyOperations.getEnum(Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(target_profile, LINKS.policies$ZwmD), CONCEPTS.DDS_Liveliness$PN)).last(), PROPS.value$EQed) : SPropertyOperations.getEnum(system_default, PROPS.liveliness$KMjY));
              // If source is AUTOMATIC and target is MANUAL_BY_TOPIC then policies are incompatible 
              if (source_liveliness.equals(SEnumOperations.getMember(MetaAdapterFactory.getEnumeration(0x331f7a18c6574dd7L, 0x870742124f20f67bL, 0x7358ab7c0bd70c6eL, "DDS.structure.LivelinessEnumeration"), 0x7358ab7c0bd70c6fL, "AUTOMATIC")) && target_liveliness.equals(SEnumOperations.getMember(MetaAdapterFactory.getEnumeration(0x331f7a18c6574dd7L, 0x870742124f20f67bL, 0x7358ab7c0bd70c6eL, "DDS.structure.LivelinessEnumeration"), 0x7358ab7c0bd70c70L, "MANUAL_BY_TOPIC"))) {
                {
                  final MessageTarget errorTarget = new NodeMessageTarget();
                  IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(connection, "The profiles " + source_profile_name + " and " + target_profile_name + " are incompatible due to liveliness policy.", "r:32754cbf-4758-422a-8eaf-16202a1e987c(ROS2.typesystem)", "3788866084217602849", null, errorTarget);
                }
              }

              // Deadline 
              int source_deadline = ((Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(source_profile, LINKS.policies$ZwmD), CONCEPTS.DDS_Deadline$a6)).last() != null) ? SPropertyOperations.getInteger(Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(source_profile, LINKS.policies$ZwmD), CONCEPTS.DDS_Deadline$a6)).last(), PROPS.value$krUq) : SPropertyOperations.getInteger(system_default, PROPS.deadline$ZtXz));
              int target_deadline = ((Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(target_profile, LINKS.policies$ZwmD), CONCEPTS.DDS_Deadline$a6)).last() != null) ? SPropertyOperations.getInteger(Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(target_profile, LINKS.policies$ZwmD), CONCEPTS.DDS_Deadline$a6)).last(), PROPS.value$krUq) : SPropertyOperations.getInteger(system_default, PROPS.deadline$ZtXz));
              // check for two cases of incompatibility 
              if (target_deadline < source_deadline) {
                {
                  final MessageTarget errorTarget = new NodeMessageTarget();
                  IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(connection, "The profiles " + source_profile_name + " and " + target_profile_name + " are incompatible due to deadline policy.", "r:32754cbf-4758-422a-8eaf-16202a1e987c(ROS2.typesystem)", "7566676200133763981", null, errorTarget);
                }
              }

              // Lease Duration 
              int source_lease = ((Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(source_profile, LINKS.policies$ZwmD), CONCEPTS.DDS_LeaseDuration$vx)).last() != null) ? SPropertyOperations.getInteger(Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(source_profile, LINKS.policies$ZwmD), CONCEPTS.DDS_LeaseDuration$vx)).last(), PROPS.value$nA9S) : SPropertyOperations.getInteger(system_default, PROPS.lease$KUKy));
              int target_lease = ((Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(target_profile, LINKS.policies$ZwmD), CONCEPTS.DDS_LeaseDuration$vx)).last() != null) ? SPropertyOperations.getInteger(Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(target_profile, LINKS.policies$ZwmD), CONCEPTS.DDS_LeaseDuration$vx)).last(), PROPS.value$nA9S) : SPropertyOperations.getInteger(system_default, PROPS.lease$KUKy));
              // check for two cases of incompatibility 
              if (target_lease < source_lease) {
                {
                  final MessageTarget errorTarget = new NodeMessageTarget();
                  IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(connection, "The profiles " + source_profile_name + " and " + target_profile_name + " are incompatible due to lease duration policy.", "r:32754cbf-4758-422a-8eaf-16202a1e987c(ROS2.typesystem)", "7566676200133834175", null, errorTarget);
                }
              }
            }
          }
        });

      }
    });
  }
  public SAbstractConcept getApplicableConcept() {
    return CONCEPTS.Connection$i2;
  }
  public IsApplicableStatus isApplicableAndPattern(SNode argument) {
    return new IsApplicableStatus(argument.getConcept().isSubConceptOf(getApplicableConcept()), null);
  }
  public boolean overrides() {
    return false;
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink sources$zOdg = MetaAdapterFactory.getContainmentLink(0x218e40b475d44de8L, 0x83e6b31e4da8bceeL, 0x17882579cafcccdcL, 0x6113a376fb4ed72eL, "sources");
    /*package*/ static final SContainmentLink targets$zI6Q = MetaAdapterFactory.getContainmentLink(0x218e40b475d44de8L, 0x83e6b31e4da8bceeL, 0x17882579cafcccdcL, 0x6113a376fb4ed729L, "targets");
    /*package*/ static final SReferenceLink ref$7ES7 = MetaAdapterFactory.getReferenceLink(0x218e40b475d44de8L, 0x83e6b31e4da8bceeL, 0x6113a376fb4efb12L, 0x78793d226ebf3bbbL, "ref");
    /*package*/ static final SReferenceLink port$FRDg = MetaAdapterFactory.getReferenceLink(0x218e40b475d44de8L, 0x83e6b31e4da8bceeL, 0x303c12ef1bceee98L, 0x303c12ef1bceee99L, "port");
    /*package*/ static final SReferenceLink profile$BWnM = MetaAdapterFactory.getReferenceLink(0x73f2d64e927d48dcL, 0x89c7793f38431f94L, 0x22f0a573da97db52L, 0x31ec195a68373325L, "profile");
    /*package*/ static final SReferenceLink ref$7FnA = MetaAdapterFactory.getReferenceLink(0x218e40b475d44de8L, 0x83e6b31e4da8bceeL, 0x6113a376fb4efb15L, 0x78793d226ebf3bbdL, "ref");
    /*package*/ static final SContainmentLink policies$ZwmD = MetaAdapterFactory.getContainmentLink(0x6d22281353ea440eL, 0xba3023ced4b723f0L, 0x75d27ff7603f6d14L, 0x75d27ff7603f6d21L, "policies");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept System$7o = MetaAdapterFactory.getConcept(0x218e40b475d44de8L, 0x83e6b31e4da8bceeL, 0x17882579cafcccdbL, "Component.structure.System");
    /*package*/ static final SConcept DefaultQoS$mx = MetaAdapterFactory.getConcept(0x73f2d64e927d48dcL, 0x89c7793f38431f94L, 0x3717cb3de2d53f21L, "ROS2.structure.DefaultQoS");
    /*package*/ static final SConcept CapabilityProfileAnnotation$9I = MetaAdapterFactory.getConcept(0x73f2d64e927d48dcL, 0x89c7793f38431f94L, 0x22f0a573da97db52L, "ROS2.structure.CapabilityProfileAnnotation");
    /*package*/ static final SConcept DDS_Reliability$EL = MetaAdapterFactory.getConcept(0x331f7a18c6574dd7L, 0x870742124f20f67bL, 0x4bc2f2a09e3b8fe4L, "DDS.structure.DDS_Reliability");
    /*package*/ static final SConcept DDS_Durability$PO = MetaAdapterFactory.getConcept(0x331f7a18c6574dd7L, 0x870742124f20f67bL, 0x4bc2f2a09e3862bdL, "DDS.structure.DDS_Durability");
    /*package*/ static final SConcept DDS_Liveliness$PN = MetaAdapterFactory.getConcept(0x331f7a18c6574dd7L, 0x870742124f20f67bL, 0x4bc2f2a09e3b8fc1L, "DDS.structure.DDS_Liveliness");
    /*package*/ static final SConcept DDS_Deadline$a6 = MetaAdapterFactory.getConcept(0x331f7a18c6574dd7L, 0x870742124f20f67bL, 0x69023be9ff596d71L, "DDS.structure.DDS_Deadline");
    /*package*/ static final SConcept DDS_LeaseDuration$vx = MetaAdapterFactory.getConcept(0x331f7a18c6574dd7L, 0x870742124f20f67bL, 0x69023be9ff596dadL, "DDS.structure.DDS_LeaseDuration");
    /*package*/ static final SConcept Connection$i2 = MetaAdapterFactory.getConcept(0x218e40b475d44de8L, 0x83e6b31e4da8bceeL, 0x17882579cafcccdcL, "Component.structure.Connection");
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
    /*package*/ static final SProperty value$HFLS = MetaAdapterFactory.getProperty(0x331f7a18c6574dd7L, 0x870742124f20f67bL, 0x4bc2f2a09e3b8fe4L, 0x4bc2f2a09e3b8fe5L, "value");
    /*package*/ static final SProperty reliability$KGFA = MetaAdapterFactory.getProperty(0x73f2d64e927d48dcL, 0x89c7793f38431f94L, 0x3717cb3de2d53f21L, 0x3717cb3de2d53f9aL, "reliability");
    /*package*/ static final SProperty value$XLjo = MetaAdapterFactory.getProperty(0x331f7a18c6574dd7L, 0x870742124f20f67bL, 0x4bc2f2a09e3862bdL, 0x4bc2f2a09e3862beL, "value");
    /*package*/ static final SProperty durability$KNg2 = MetaAdapterFactory.getProperty(0x73f2d64e927d48dcL, 0x89c7793f38431f94L, 0x3717cb3de2d53f21L, 0x3717cb3de2d53fa1L, "durability");
    /*package*/ static final SProperty value$EQed = MetaAdapterFactory.getProperty(0x331f7a18c6574dd7L, 0x870742124f20f67bL, 0x4bc2f2a09e3b8fc1L, 0x4bc2f2a09e3b8fc2L, "value");
    /*package*/ static final SProperty liveliness$KMjY = MetaAdapterFactory.getProperty(0x73f2d64e927d48dcL, 0x89c7793f38431f94L, 0x3717cb3de2d53f21L, 0x3717cb3de2d53f9dL, "liveliness");
    /*package*/ static final SProperty value$krUq = MetaAdapterFactory.getProperty(0x331f7a18c6574dd7L, 0x870742124f20f67bL, 0x69023be9ff596d71L, 0x69023be9ff596d74L, "value");
    /*package*/ static final SProperty deadline$ZtXz = MetaAdapterFactory.getProperty(0x73f2d64e927d48dcL, 0x89c7793f38431f94L, 0x3717cb3de2d53f21L, 0x3717cb3de2d54165L, "deadline");
    /*package*/ static final SProperty value$nA9S = MetaAdapterFactory.getProperty(0x331f7a18c6574dd7L, 0x870742124f20f67bL, 0x69023be9ff596dadL, 0x69023be9ff596daeL, "value");
    /*package*/ static final SProperty lease$KUKy = MetaAdapterFactory.getProperty(0x73f2d64e927d48dcL, 0x89c7793f38431f94L, 0x3717cb3de2d53f21L, 0x3717cb3de2d53facL, "lease");
  }
}
